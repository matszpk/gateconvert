use crate::xor_table::*;
use gatesim::*;
use static_init::dynamic;
use std::str::FromStr;

// generated by using gen_all_4bit_funcs from crate gateexamples0.
// Line format: number_of_values: list_of_inputs circuit
// number_of_values - decimal value of combination of outputs for all input values.
//     start from lowest bit.
//     Example: 9 - 0b1001 - true for 0b0001 (1 value and bit) and 0b0011 (3 value and bit).
// list_of_inputs - int Rust format list of inputs.
//     index - final input bit, value - original input bit.
// circuit - circuit in printable form.
const PERFECT_4INPUT_CIRCUITS: &'static str = include_str!("all_4bit_funcs.txt");

#[dynamic]
static PERFECT_4INPUT_CIRCUITS_LINES: Vec<&'static str> =
    PERFECT_4INPUT_CIRCUITS.split('\n').collect::<Vec<_>>();

fn parse_perfect_circuit_line(line: &str) -> (u32, Vec<usize>, Circuit<usize>) {
    println!("Line: {}", line);
    let num_end = line.bytes().position(|x| !x.is_ascii_digit()).unwrap();
    let value = line[0..num_end].parse().unwrap();
    let mut line = line[num_end..].trim_start();
    line = if line.starts_with(':') {
        &line[1..]
    } else {
        panic!("Unknown data");
    };
    line = line.trim_start();
    let mut inputs = vec![];
    if line.starts_with('[') {
        line = &line[1..];
        loop {
            line = line.trim_start();
            if line.starts_with(']') {
                line = &line[1..];
                break;
            }
            let num_end = line.bytes().position(|x| !x.is_ascii_digit()).unwrap();
            inputs.push(line[0..num_end].parse().unwrap());
            line = line[num_end..].trim_start();
            if line.starts_with(']') {
                line = &line[1..];
                break;
            } else if line.starts_with(',') {
                line = &line[1..];
            }
        }
    } else {
        panic!("Unknown data");
    }
    line = line.trim_start();
    let circuit = Circuit::from_str(line).unwrap();
    (value, inputs, circuit)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_perfect_circuit_line() {
        assert_eq!(
            (
                31,
                vec![0, 1, 2, 3],
                Circuit::new(
                    4,
                    [
                        Gate::new_nor(0, 1),
                        Gate::new_nimpl(2, 4),
                        Gate::new_nor(3, 5),
                    ],
                    [(6, false)]
                )
                .unwrap()
            ),
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[30])
        );
        assert_eq!(
            (
                0xdada,
                vec![0, 1, 2],
                Circuit::new(
                    3,
                    [
                        Gate::new_and(0, 1),
                        Gate::new_xor(0, 2),
                        Gate::new_nor(3, 4),
                    ],
                    [(5, true)]
                )
                .unwrap()
            ),
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[0xdada - 1])
        );
    }
}
