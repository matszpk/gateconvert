use crate::xor_table::*;
use gategen::boolvar::*;
use gategen::dynintvar::*;
use gatesim::*;
use static_init::dynamic;
use std::str::FromStr;

// generated by using gen_all_4bit_funcs from crate gateexamples0.
// Line format: number_of_values: list_of_inputs circuit
// number_of_values - decimal value of combination of outputs for all input values.
//     start from lowest bit.
//     Example: 9 - 0b1001 - true for 0b0001 (1 value and bit) and 0b0011 (3 value and bit).
// list_of_inputs - int Rust format list of inputs.
//     index - final input bit, value - original input bit.
// circuit - circuit in printable form.
const PERFECT_4INPUT_CIRCUITS: &'static str = include_str!("all_4bit_funcs.txt");

#[dynamic]
static PERFECT_4INPUT_CIRCUITS_LINES: Vec<&'static str> =
    PERFECT_4INPUT_CIRCUITS.split('\n').collect::<Vec<_>>();

fn parse_perfect_circuit_line(line: &str) -> (u32, Vec<usize>, Circuit<usize>) {
    println!("Line: {}", line);
    let num_end = line.bytes().position(|x| !x.is_ascii_digit()).unwrap();
    let value = line[0..num_end].parse().unwrap();
    let mut line = line[num_end..].trim_start();
    line = if line.starts_with(':') {
        &line[1..]
    } else {
        panic!("Unknown data");
    };
    line = line.trim_start();
    let mut inputs = vec![];
    if line.starts_with('[') {
        line = &line[1..];
        loop {
            line = line.trim_start();
            if line.starts_with(']') {
                line = &line[1..];
                break;
            }
            let num_end = line.bytes().position(|x| !x.is_ascii_digit()).unwrap();
            inputs.push(line[0..num_end].parse().unwrap());
            line = line[num_end..].trim_start();
            if line.starts_with(']') {
                line = &line[1..];
                break;
            } else if line.starts_with(',') {
                line = &line[1..];
            }
        }
    } else {
        panic!("Unknown data");
    }
    line = line.trim_start();
    let circuit = Circuit::from_str(line).unwrap();
    (value, inputs, circuit)
}

fn gen_perfect_circuit(value: u16, inputvar: &UDynVarSys) -> BoolVarSys {
    if value == 0 {
        false.into()
    } else if value == 0xffff {
        true.into()
    } else {
        let (_, inputs, circuit) =
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[(value as usize) - 1]);
        BoolVarSys::from_circuit(circuit, inputs.into_iter().map(|i| inputvar.bit(i)))[0].clone()
    }
}

fn gen_booltable_circuit_by_xor_table(table: &[bool]) -> (Circuit<usize>, Vec<Option<usize>>) {
    let table_len = table.len();
    let table_len_bits = (usize::BITS - table_len.leading_zeros() - 1) as usize;
    assert_eq!(table_len.count_ones(), 1);
    if table_len >= 16 {
        let all_inputs = UDynVarSys::var(table_len_bits);
        let int_inputs = all_inputs.subvalue(0, 4); // get lowest 4-bit of input
        let ec = get_expr_creator_sys();
        // generate expression table from perfect circuits
        let expr_table = (0..table_len >> 4)
            .map(|i| {
                let cur_val_table = &table[(i << 4)..(i << 4) + 1];
                let value = cur_val_table
                    .iter()
                    .enumerate()
                    .fold(0u16, |a, (b, v)| a | (u16::from(*v) << b));
                gen_perfect_circuit(value, &int_inputs).into()
            })
            .collect::<Vec<_>>();
        // generate table by using xor_table
        gen_table_circuit_bool(
            ec,
            int_inputs.iter().map(|v| v.into()).collect::<Vec<_>>(),
            expr_table,
        )
    } else {
        // table_len is power of two.
        let mask = table_len - 1;
        // with using indexing (b & mask) with iterator (0..16) we just duplicate
        // lowest bits
        let inputs = UDynVarSys::var(table_len_bits);
        let value = (0..16).fold(0u16, |a, b| a | (u16::from(table[b & mask]) << b));
        let output = gen_perfect_circuit(value, &inputs);
        output.to_translated_circuit_with_map(inputs.iter())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_perfect_circuit_line() {
        assert_eq!(
            (
                31,
                vec![0, 1, 2, 3],
                Circuit::new(
                    4,
                    [
                        Gate::new_nor(0, 1),
                        Gate::new_nimpl(2, 4),
                        Gate::new_nor(3, 5),
                    ],
                    [(6, false)]
                )
                .unwrap()
            ),
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[30])
        );
        assert_eq!(
            (
                0xdada,
                vec![0, 1, 2],
                Circuit::new(
                    3,
                    [
                        Gate::new_and(0, 1),
                        Gate::new_xor(0, 2),
                        Gate::new_nor(3, 4),
                    ],
                    [(5, true)]
                )
                .unwrap()
            ),
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[0xdada - 1])
        );
    }
}
