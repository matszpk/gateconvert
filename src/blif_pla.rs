use crate::xor_table::*;
use gategen::boolvar::*;
use gategen::dynintvar::*;
use gatesim::*;
use static_init::dynamic;
use std::collections::HashMap;
use std::str::FromStr;

// generated by using gen_all_4bit_funcs from crate gateexamples0.
// Line format: number_of_values: list_of_inputs circuit
// number_of_values - decimal value of combination of outputs for all input values.
//     start from lowest bit.
//     Example: 9 - 0b1001 - true for 0b0001 (1 value and bit) and 0b0011 (3 value and bit).
// list_of_inputs - int Rust format list of inputs.
//     index - final input bit, value - original input bit.
// circuit - circuit in printable form.
const PERFECT_4INPUT_CIRCUITS: &'static str = include_str!("all_4bit_funcs.txt");

#[dynamic]
static PERFECT_4INPUT_CIRCUITS_LINES: Vec<&'static str> =
    PERFECT_4INPUT_CIRCUITS.split('\n').collect::<Vec<_>>();

fn parse_perfect_circuit_line(line: &str) -> (u32, Vec<usize>, Circuit<usize>) {
    let num_end = line.bytes().position(|x| !x.is_ascii_digit()).unwrap();
    let value = line[0..num_end].parse().unwrap();
    let mut line = line[num_end..].trim_start();
    line = if line.starts_with(':') {
        &line[1..]
    } else {
        panic!("Unknown data");
    };
    line = line.trim_start();
    let mut inputs = vec![];
    if line.starts_with('[') {
        line = &line[1..];
        loop {
            line = line.trim_start();
            if line.starts_with(']') {
                line = &line[1..];
                break;
            }
            let num_end = line.bytes().position(|x| !x.is_ascii_digit()).unwrap();
            inputs.push(line[0..num_end].parse().unwrap());
            line = line[num_end..].trim_start();
            if line.starts_with(']') {
                line = &line[1..];
                break;
            } else if line.starts_with(',') {
                line = &line[1..];
            }
        }
    } else {
        panic!("Unknown data");
    }
    line = line.trim_start();
    let circuit = Circuit::from_str(line).unwrap();
    (value, inputs, circuit)
}

type CircuitCache = HashMap<u16, (u32, Vec<usize>, Circuit<usize>)>;

fn gen_perfect_expr(cache: &mut CircuitCache, value: u16, inputvar: &UDynVarSys) -> BoolVarSys {
    if value == 0 {
        false.into()
    } else if value == 0xffff {
        true.into()
    } else {
        let (_, inputs, circuit) = if let Some(t) = cache.get(&value) {
            t.clone()
        } else {
            let t = parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[(value as usize) - 1]);
            cache.insert(value, t.clone());
            t
        };
        BoolVarSys::from_circuit(circuit, inputs.into_iter().map(|i| inputvar.bit(i)))[0].clone()
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum TableCircuit {
    Value(bool),
    Circuit((Circuit<usize>, Vec<Option<usize>>)),
}

fn gen_perfect_circuit(cache: &mut CircuitCache, value: u16) -> TableCircuit {
    if value == 0 {
        TableCircuit::Value(false)
    } else if value == 0xffff {
        TableCircuit::Value(false)
    } else {
        let (_, inputs, circuit) = if let Some(t) = cache.get(&value) {
            t.clone()
        } else {
            let t = parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[(value as usize) - 1]);
            cache.insert(value, t.clone());
            t
        };
        let mut out_inputs = vec![None; 4];
        for (newi, i) in inputs.into_iter().enumerate() {
            out_inputs[i] = Some(newi);
        }
        TableCircuit::Circuit((circuit, out_inputs))
    }
}

fn gen_booltable_circuit_by_xor_table(cache: &mut CircuitCache, table: &[bool]) -> TableCircuit {
    let table_len = table.len();
    let table_len_bits = (usize::BITS - table_len.leading_zeros() - 1) as usize;
    assert_eq!(table_len.count_ones(), 1);
    if table.iter().all(|x| !*x) {
        // if all elements in table are false
        TableCircuit::Value(false)
    } else if table.iter().all(|x| *x) {
        // if all elements in table are true
        TableCircuit::Value(true)
    } else if table_len > 16 {
        callsys(|| {
            let mut perfect_expr_map = HashMap::<u16, BoolVarSys>::new();
            // prepare real table for XOR table
            let mut valtable = vec![0u16; table.len() >> 4];
            for i in 0..table_len >> 4 {
                let cur_val_table = &table[(i << 4)..(i << 4) + 16];
                let value = cur_val_table
                    .into_iter()
                    .enumerate()
                    .fold(0u16, |a, (b, v)| a | (u16::from(*v) << b));
                valtable[i] = value;
            }
            let mut xor_elem_outputs: Vec<u16> = vec![];
            let mut temp_elem_outputs: Vec<Vec<u16>> = vec![];
            type_extend_prep_xor_table(
                &mut xor_elem_outputs,
                &mut temp_elem_outputs,
                valtable.iter().copied(),
            );
            // generate perfect circuit for real table for XOR table.
            let int_inputs = UDynVarSys::var(4); // get lowest 4-bit of input
            let ec = get_expr_creator_sys();
            // generate expression table from perfect circuits
            let expr_table = (0..table_len >> 4)
                .map(|i| {
                    let value = xor_elem_outputs[i];
                    let expr = if let Some(expr) = perfect_expr_map.get(&value) {
                        println!("Copy of {}", value);
                        expr.clone()
                    } else {
                        let expr = gen_perfect_expr(cache, value, &int_inputs);
                        perfect_expr_map.insert(value, expr.clone());
                        expr
                    };
                    expr.into()
                })
                .collect::<Vec<_>>();
            // generate table by using xor_table
            TableCircuit::Circuit(gen_table_circuit_bool_prep(
                ec,
                int_inputs.iter().map(|v| v.into()).collect::<Vec<_>>(),
                expr_table,
            ))
        })
    } else {
        // table_len is power of two.
        let mask = table_len - 1;
        // with using indexing (b & mask) with iterator (0..16) we just duplicate
        // lowest bits
        let value = (0..16).fold(0u16, |a, b| a | (u16::from(table[b & mask]) << b));
        let mut out = gen_perfect_circuit(cache, value);
        if let TableCircuit::Circuit((_, input)) = &mut out {
            // fix size of inputs
            input.resize(table_len_bits, None);
        }
        out
    }
}

#[repr(u8)]
#[derive(Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord)]
enum PLACell {
    #[default]
    Zero,
    Unknown,
    One,
}

// algorithm to convert from PLA to Truth-Table:
// PLA entries must be sorted lexicographically.
// for all Truth table netry:
//    l = lowest_PLA_entry, h = highest_PLA_entry.
//    find in PLAentries.range(l,h) entry that match to truth entry.
//    if matched then set specified value (if 1 then 1), otherwise other (if 1 then 0).

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_perfect_circuit_line() {
        assert_eq!(
            (
                31,
                vec![0, 1, 2, 3],
                Circuit::new(
                    4,
                    [
                        Gate::new_nor(0, 1),
                        Gate::new_nimpl(2, 4),
                        Gate::new_nor(3, 5),
                    ],
                    [(6, false)]
                )
                .unwrap()
            ),
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[30])
        );
        assert_eq!(
            (
                0xdada,
                vec![0, 1, 2],
                Circuit::new(
                    3,
                    [
                        Gate::new_and(0, 1),
                        Gate::new_xor(0, 2),
                        Gate::new_nor(3, 4),
                    ],
                    [(5, true)]
                )
                .unwrap()
            ),
            parse_perfect_circuit_line(PERFECT_4INPUT_CIRCUITS_LINES[0xdada - 1])
        );
    }

    fn str_to_vecbool(s: &str) -> Vec<bool> {
        s.chars()
            .filter(|x| *x == '0' || *x == '1')
            .map(|x| x == '1')
            .collect()
    }

    fn check_circuit(exp_table: &[bool], table_circuit: TableCircuit) {
        // println!("Check for {:?}", exp_table.len());
        match table_circuit {
            TableCircuit::Circuit((circuit, inputs)) => {
                // println!("Inputsfilter: {:?}", inputs
                //                 .iter()
                //                 .enumerate()
                //                 .filter_map(|(i, x)| (*x).map(|_| i)).collect::<Vec<_>>());
                for (i, expv) in exp_table.into_iter().enumerate() {
                    let out = circuit.eval(
                        // convert from inputs in form [None,...,Some(new_index),...]
                        // to [....,old_index,..]
                        inputs
                            .iter()
                            .enumerate()
                            .filter_map(|(i, x)| (*x).map(|_| i))
                            .map(|b| ((i >> b) & 1) != 0),
                    );
                    assert_eq!(*expv, out[0], "{}", i);
                }
            }
            TableCircuit::Value(val) => {
                assert!(exp_table.iter().all(|x| *x == val));
            }
        }
    }

    fn gen_xor_booltable_circuit_and_check(s: &str) {
        let mut cache = CircuitCache::new();
        let table = str_to_vecbool(s);
        let table_circuit = gen_booltable_circuit_by_xor_table(&mut cache, &table);
        check_circuit(&table, table_circuit);
    }

    fn gen_xor_booltable_circuit_and_check_2(data: &[u64]) {
        let mut cache = CircuitCache::new();
        let table = data
            .iter()
            .map(|x| (0..64).map(|i| ((*x >> i) & 1) != 0))
            .flatten()
            .collect::<Vec<bool>>();
        let table_circuit = gen_booltable_circuit_by_xor_table(&mut cache, &table);
        if let TableCircuit::Circuit((circuit, _)) = &table_circuit {
            println!("Circuit len: {}", circuit.len());
        }
        check_circuit(&table, table_circuit);
    }

    #[test]
    fn test_gen_booltable_circuit_by_xor_table() {
        gen_xor_booltable_circuit_and_check("0");
        gen_xor_booltable_circuit_and_check("1");
        gen_xor_booltable_circuit_and_check("00");
        gen_xor_booltable_circuit_and_check("11");
        gen_xor_booltable_circuit_and_check("0000");
        gen_xor_booltable_circuit_and_check("1111");
        gen_xor_booltable_circuit_and_check("00000000");
        gen_xor_booltable_circuit_and_check("11111111");
        gen_xor_booltable_circuit_and_check("00000000_00000000");
        gen_xor_booltable_circuit_and_check("11111111_11111111");
        gen_xor_booltable_circuit_and_check("00000000_00000000_00000000_00000000");
        gen_xor_booltable_circuit_and_check("11111111_11111111_11111111_11111111");
        gen_xor_booltable_circuit_and_check(&std::iter::repeat('0').take(1024).collect::<String>());
        gen_xor_booltable_circuit_and_check(&std::iter::repeat('1').take(1024).collect::<String>());
        gen_xor_booltable_circuit_and_check("01");
        gen_xor_booltable_circuit_and_check("10");
        gen_xor_booltable_circuit_and_check("0001");
        gen_xor_booltable_circuit_and_check("0010");
        gen_xor_booltable_circuit_and_check("0100");
        gen_xor_booltable_circuit_and_check("1000");
        gen_xor_booltable_circuit_and_check("0110");
        gen_xor_booltable_circuit_and_check("1001");
        gen_xor_booltable_circuit_and_check("0101");
        gen_xor_booltable_circuit_and_check("1100");
        gen_xor_booltable_circuit_and_check("01100100_01001101");
        gen_xor_booltable_circuit_and_check("01100110_01000100");
        gen_xor_booltable_circuit_and_check("01011111_10100101");
        gen_xor_booltable_circuit_and_check("10111011_10111011");
        gen_xor_booltable_circuit_and_check("00011010_01000100_01111001_01011010");
        gen_xor_booltable_circuit_and_check("11001100_00110011_10101010_01010101");
        gen_xor_booltable_circuit_and_check(concat!(
            "00010101_00010101_11100110_11011110",
            "11001011_10001000_11110111_11010111",
            "00111001_11011001_00001000_00010111",
            "11101101_01100010_01100010_11101111",
        ));
        gen_xor_booltable_circuit_and_check(concat!(
            "00000000_00000000_11111111_11111111",
            "11111111_11111111_00000000_00000000",
            "00000000_00000000_00000000_00000000",
            "11111111_11111111_11111111_11111111",
        ));
        let mut data = vec![0u64; 128];
        data[0] = 0xfac0d0a0341acdab;
        data[1] = 0x60da03491bc8da91;
        data[2] = 0x57dd9840a894bc0d;
        for i in 3..data.len() {
            data[i] = data[i - 3].overflowing_mul(data[i - 2]).0 ^ data[i - 1];
        }
        gen_xor_booltable_circuit_and_check_2(&data);
    }
}
